<!DOCTYPE html>
<html>
  <head>
    <title>Drashland / Sockets</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss/dist/tailwind.min.css"/>
  </head>
  <body class="p-5">
    <div class="flex">
      <div class="w-1/2 p-5">
        <p class="mb-5">
          <strong>Open your console and follow the instructions below.</strong>
        </p>
        <p class="mb-2">1. Create a new connection to the socket server. This will be your socket client.</p>
        <pre class="mb-5 border-t border-r border-b border-l border-gray-400 rounded-b p-4 overflow-auto bg-gray-200"><code>const socketClient = new SocketClient({
  hostname: "localhost",
  port: 3000,
  protocol: "wss"
});</code></pre>
        <p class="mb-2">2. When the socket server starts, it creates a channel named "Channel 1", so we set this socket client up to listen to that channel here. Any messages sent by the socket server to "Channel 1" will be handled by the callback below (the second argument).</p>
        <pre class="mb-5 border-t border-r border-b border-l border-gray-400 rounded-b p-4 overflow-auto bg-gray-200"><code>socketClient.on("Channel 1", (incomingMessage) => {
  console.log(
    "Message received from the server: " + JSON.stringify(incomingMessage),
  );
  const messages = document.getElementById("messages");
  const li = document.createElement("li");
  li.appendChild(document.createTextNode(incomingMessage.text));
  messages.appendChild(li);
});</code></pre>
        <p class="mb-2">3. Send a message to the socket server.</p>
        <pre class="mb-5 border-t border-r border-b border-l border-gray-400 rounded-b p-4 overflow-auto bg-gray-200"><code>socketClient.to("Channel 1", "Hello, world!");</code></pre>
      </div>
      <div class="w-1/2 p-5">
        <p class="mb-5">
          <strong>Messages received from the socket server:</strong>
        </p>
        <ul id="messages"></ul>
      </div>
    </div>
    <script>
const reader = new FileReader();

/**
 * @description
 *    This SocketClient class uses the native WebSocket object to create a connection to a socket
 *    server. It creates a connection, handles messages received from the socket server, and can
 *    send messages to the socket server it is connected to.
 *
 *    There are two methods that allow this class to interact with the socket server it is connected
 *    to. Those methods are:
 *
 *        - on(); and
 *        - to()
 *
 *    Use these methods to interact with the connected socket server.
 *
 *    There are methods in this class that are prefixed with an underscore. A method prefixed with
 *    an underscore means it is not meant to be used publicly. Although these methods are not
 *    private, these methods are mainly for the SocketClient class' use.
 *
 *    Helpful links:
 *    - Learn more about the WebSocket API at the following address:
 *          https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
 *    - Learn more about writing web socket client applications at the following address:
 *          https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications
 */
class SocketClient {
  /**
   * @description
   *     Construct an object of this class.
   *
   * @return {SocketClient}
   */
  constructor(options) {
    this.configs = {
      hostname: options.hostname || "localhost",
      port: options.port || "3000",
      protocol: options.protocol || "ws",
    };
    this.data = null;
    this.decoder = new TextDecoder();
    this.file_reader = new FileReader();
    this.listening_to = {};
    this.message_queue = [];
    this.ready = true;

    this._connectToSocketServer();
    this._listenToSocketServerMessages();
    this.file_reader.addEventListener('loadend', (e) => {
      const json = JSON.parse(e.srcElement.result);
      this._handleJsonMessage(json);
    });

    return this;
  }

  // FILE MARKER - METHODS FOR PUBLIC USE //////////////////////////////////////////////////////////

  /**
   * @description
   *     On receipt of a message in the following channel or on the following event, perform the
   *     specified callback.
   *
   * @param {String} channelOrEvent
   *     The name of the channel or event.
   * @param {Function} callback
   *     The callback to execute on receipt of a message from the channel or event.
   */
  on(channelOrEvent, callback) {
    if (this.connection.readyState === 1) {
      if (!this.listening_to[channelOrEvent]) {
        this.listening_to[channelOrEvent] = null;
      }
      this.listening_to[channelOrEvent] = callback;
      const message = JSON.stringify({ listening_to: channelOrEvent });
      const encoded = new TextEncoder().encode(message);
      this.message_queue.push(encoded);
      this._sendMessagesToSocketServer();
    } else {
      setTimeout(() => this.on(channelOrEvent, callback), 5);
    }
  }

  /**
   * @description
   *     Send a message to a channel or an event.
   *
   * @param {String} channelOrEvent
   *     The name of the channel or event.
   * @param {String} message
   *     The message to send to the channel or event.
   */
  to(channelOrEvent, message) {
    if (channelOrEvent) {
      message = JSON.stringify({ [channelOrEvent]: message });
      message = new TextEncoder().encode(message);
    }
    this.message_queue.push(message);
    this._sendMessagesToSocketServer();
  }

  // FILE MARKER - METHODS FOR INTERNAL USE ////////////////////////////////////////////////////////

  /**
   * Connect to the socket server at the hostname and port specified in the configs.
   */
  _connectToSocketServer() {
    this.connection = new WebSocket(
      `${this.configs.protocol}://${this.configs.hostname}:${this.configs.port}`,
    );
  }

  /**
   * @description
   *     Listen to messages from sent by the socket server.
   */
  _listenToSocketServerMessages() {
    this.connection.addEventListener("message", (event) => {
      let data = event.data;
      switch (data.constructor.name) {
        case "Blob":
            this.file_reader.readAsText(data);
          break;
        default:
          this._handleEncodedMessage(data);
          break;

      }
    });
  }

  /**
   * @description
   *     All messages received by the socket server will be handled by this method.
   *
   * @param {Body}
   *     The encoded message. See https://developer.mozilla.org/en-US/docs/Web/API/Body for more
   *     information about the Body mixin.
   */
  _handleEncodedMessage(encodedMessage) {
    encodedMessage.arrayBuffer().then((buffer) => {
      const decodedMessage = this.decoder.decode(buffer);
      const json = JSON.parse(decodedMessage);
      this_handleJsonMessage(json);
    });
  }

  _handleJsonMessage(json) {
    Object.keys(json).forEach((channelOrEvent) => {
      if (this.listening_to[channelOrEvent]) {
        this.listening_to[channelOrEvent](json[channelOrEvent]);
      }
    });
  }

  /**
   * @description
   *     Send all messages in the message queue to the socket server.
   */
  _sendMessagesToSocketServer() {
    if (this.ready && this.message_queue.length) {
      this.ready = false;
      let message = null;
      while (this.message_queue.length) {
        message = new Uint8Array(this.message_queue[0].length);
        message.set(this.message_queue.pop());
      }
      this.connection.send(message);
      this.ready = true;
      this._sendMessagesToSocketServer();
    }
  }
}


    </script>
  </body>
</html>
